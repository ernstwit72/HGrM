#include "tRNG.h"
#include "tRNG.private.h"

// MSDN claims _CrtDbgReport() is declared but empty when _DEBUG is not defined
// actually i get compilation errors, so i declare it here
#ifndef _DEBUG
void _CrtDbgReport(int, ...) {}
#endif

int tRNG::Error() {
	return Status;
}

tRNG::tRNG(int buffer_size, int iterations, int settings) {
    Status = TRNG_NO_ERROR;

	_CrtDbgReport(_CRT_WARN, NULL, NULL, NULL, "\ntRNG library (v.%d)\n2004-2005 CAFxX\n\n", Version);
    
    // check if the parameters are correct, otherwise use default values
	if (buffer_size <= 0) { BufferSize = DEFAULT_BUFFER_SIZE; } else { BufferSize = buffer_size & ~3; }
	if (iterations <= 0)  { Iterations = DEFAULT_ITERATIONS; }  else { Iterations = iterations; }
    if (settings & TRNG_ENABLE_UNBIASER)         { UseUnbiasing = true; }       else { UseUnbiasing = false; }
    if (settings & TRNG_ENABLE_QUALITY_CONTROL)  { UseQualityControl = true; }  else { UseQualityControl = false; }
    if (settings & TRNG_ENABLE_FHSPRNG)          { UseFHSpRNG = true; }         else { UseFHSpRNG = false; }
    if (settings & TRNG_ENABLE_AUTOMATIC_MODE)   { UseAutomaticMode = true; }   else { UseAutomaticMode = false; }
    if (settings & TRNG_DISABLE_LOOP_COUNT)		 { DisableLoop = true; }        else { DisableLoop = false; }
	// if the buffer is too small, the chi square testing isn't significant: in this case disable quality controls
	// regardless of the settings above
	if (BufferSize < 5000) { UseQualityControl = false; } 

    // allocate buffers
	if ((DispenserBuffer = (char*)malloc(BufferSize)) == NULL) { Status = TRNG_BAD_ALLOCATION; return; }
    if ((GeneratorBuffer = (char*)malloc(BufferSize)) == NULL) { Status = TRNG_BAD_ALLOCATION; return; }

    // mark the DispenserBuffer as read, so that the first time the rand() function
	// gets called, it copies the contents of the GeneratorBuffer
	DispenserBufferPosition = BufferSize;
	GeneratorBufferIsReady = false;
	
	// initialize GeneratorReset to false
	GeneratorReset = false;

	// initialize the soundcard (if present)
	InitSource();
	if (Status) { return; }

	// initialize some conuters
	BuffersGenerated = 0;
    Underruns = 0;
	BytesServed = 0;

	_CrtDbgReport(_CRT_WARN, NULL, NULL, NULL, "Settings:\n");
	if (UseUnbiasing) _CrtDbgReport(_CRT_WARN, NULL, NULL, NULL, "UseUnbiasing \n");
	if (UseQualityControl) _CrtDbgReport(_CRT_WARN, NULL, NULL, NULL, "UseQualityControl \n");
	if (UseFHSpRNG) _CrtDbgReport(_CRT_WARN, NULL, NULL, NULL, "UseFHSpRNG \n");
	if (UseAutomaticMode) _CrtDbgReport(_CRT_WARN, NULL, NULL, NULL, "UseAutomaticMode \n");
	if (DisableLoop) _CrtDbgReport(_CRT_WARN, NULL, NULL, NULL, "DisableLoop \n");
	_CrtDbgReport(_CRT_WARN, NULL, NULL, NULL, "BufferSize: %d\n", BufferSize);
	_CrtDbgReport(_CRT_WARN, NULL, NULL, NULL, "Iterations: %d\n", Iterations);

	// start the generator thread
	CreateGeneratorThread();

	#ifdef _DEBUG
	Dump();
	#endif
}

tRNG::~tRNG() {
	_CrtDbgReport(_CRT_WARN, NULL, NULL, NULL, "\nGenerated bytes %d\nGenerated buffers %d\nUnderruns %d\nStatus %d\n", BytesServed, BuffersGenerated, Underruns, Status);
	#ifdef _DEBUG
	Dump();
	#endif
    Status = TRNG_SHUTDOWN;
	while (GeneratorIsRunning) { Sleep(DEFAULT_WAIT_INTERVAL); }
	CloseSource();
    free(DispenserBuffer);
    free(GeneratorBuffer);
}

int tRNG::rand() {
    // if something is wrong, abort
	if (Status != TRNG_NO_ERROR) return 0; 
	// if there are no more available bytes in DispenserBuffer
	if (DispenserBufferPosition >= BufferSize) { 
		while (!GeneratorBufferIsReady) { // then wait for the GeneratorBuffer to be ready
			// if the GeneratorBuffer isn't ready and automatic mode is on, switch to turbo mode
			if (UseAutomaticMode) return prand(); 
			// this checks if the generator thread is working properly
			if (Status) return 0; 
			// just a counter
			Underruns++;
			// suspend execution for some time, not to waste system resources
			Sleep(DEFAULT_WAIT_INTERVAL); 
		};
		memcpy(DispenserBuffer, GeneratorBuffer, BufferSize); // copy the random bytes to DispenserBuffer
        DispenserBufferPosition = 0; // set the DispenserBuffer position to 0
        GeneratorBufferIsReady = false; // mark the GeneratorBuffer as not ready
		if (DisableLoop) { 
			GeneratorReset = true;
		} else {
			CreateGeneratorThread(); // and then execute the generator
		}
    }
    int RandomData = *reinterpret_cast<int*>(&DispenserBuffer[DispenserBufferPosition]); // return 4 random bytes
    DispenserBufferPosition += 4;
	BytesServed += 4;
    return RandomData;
}

int tRNG::prand() {
	return 0;
}

// Generate is the function running in the second thread. This is where samples are gathered and processed
void tRNG::Generate() {
	GeneratorIsRunning = true;
	GeneratorThreadID = GetCurrentThreadId();
	_CrtDbgReport(_CRT_WARN, NULL, NULL, NULL, "GeneratorThread %d (%d)\n", GeneratorThreadID, BuffersGenerated);

    // Loops is used to prevent the function from looping indefinitely
	// if Loops becomes greater then DEFAULT_LOOPS_LIMIT, the function will abort
	int Loops = 0, Temp;
	
    memset(GeneratorBuffer, 0, BufferSize); // clear the GeneratorBuffer
    
	Loop: // start recording
	if (Status == TRNG_SHUTDOWN) {
		GeneratorIsRunning = false;
		return;
	}
	waveinputheader.lpData = (char*)malloc(BufferSize * Iterations * waveinputformat.wBitsPerSample);
    waveinputheader.dwBufferLength = BufferSize * Iterations * waveinputformat.wBitsPerSample;
    waveinputheader.dwBytesRecorded = 0;
    waveinputheader.dwUser = 0; 
    waveinputheader.dwFlags = 0; 
    waveinputheader.dwLoops = 0; 
    if (MMSYSERR_NOERROR != waveInPrepareHeader(waveinputhandle, &waveinputheader, sizeof(WAVEHDR))) 
		{ Status = TRNG_MMSYSTEM_ERROR; return; }
    if (MMSYSERR_NOERROR != waveInAddBuffer(waveinputhandle, &waveinputheader, sizeof(WAVEHDR))) 
		{ Status = TRNG_MMSYSTEM_ERROR; return; }
    if (MMSYSERR_NOERROR != waveInStart(waveinputhandle)) 
		{ Status = TRNG_MMSYSTEM_ERROR; return; }
    // wait until recording it's over
    Sleep((1000 * waveinputheader.dwBufferLength) / waveinputformat.nAvgBytesPerSec);
    while (!(waveinputheader.dwFlags & WHDR_DONE)) Sleep(DEFAULT_WAIT_INTERVAL);	
	// stop recording
	if (MMSYSERR_NOERROR != waveInUnprepareHeader(waveinputhandle, &waveinputheader, sizeof(WAVEHDR))) 
		{ Status = TRNG_MMSYSTEM_ERROR; return; }
    if (MMSYSERR_NOERROR != waveInReset(waveinputhandle)) 
		{ Status = TRNG_MMSYSTEM_ERROR; return; }
	// estimate entropy
	_CrtDbgReport(_CRT_WARN, NULL, NULL, NULL, "EstimateEntropy: %d bits\n", EstimateEntropy(waveinputheader.lpData));
	// hash data
	if (UseFHSpRNG || UseAutomaticMode) {
		for (int c=0; c<BufferSize*Iterations*waveinputformat.wBitsPerSample; c++) {
			Temp = _lrotl(waveinputheader.lpData[c], (DEFAULT_PRIME_NUMBER*c)%8);
			GeneratorBuffer[(c >> 3) % BufferSize] ^= Temp;
			Seed[c % DEFAULT_PRNG_INSTANCES] ^= Temp;
		}
	} else {
	    for (int c=0; c<BufferSize * Iterations * waveinputformat.wBitsPerSample; c++) 
			GeneratorBuffer[(c / waveinputformat.wBitsPerSample) % BufferSize] ^= _rotl(waveinputheader.lpData[c], (DEFAULT_PRIME_NUMBER * c) % 8);
	}
	free(waveinputheader.lpData);

	// if disableloop is enabled, keep on looping until generatorreset is set to true by the dispenser, then 
	// clear the generatorbuffer and restart
	if (DisableLoop) {
		if (GeneratorReset) {
			Loops = 0;
			memset(GeneratorBuffer, 0, BufferSize);
			_CrtDbgReport(_CRT_WARN, NULL, NULL, NULL, "Generator Buffer released (%d)\n", BuffersGenerated);
			BuffersGenerated++;
			GeneratorReset = false;
		} else if (GeneratorBufferIsReady) {
			Loops++;
			_CrtDbgReport(_CRT_WARN, NULL, NULL, NULL, "Additional Loop %d\n", Loops);
		} else {
			if (UseQualityControl) {
				if(!ControlQuality()) {
					GeneratorBufferIsReady = true;
					_CrtDbgReport(_CRT_WARN, NULL, NULL, NULL, "Additional Loop %d\n", Loops);
				}
			} else {
				GeneratorBufferIsReady = true;
				_CrtDbgReport(_CRT_WARN, NULL, NULL, NULL, "Additional Loop %d\n", Loops);
			}
		}
		goto Loop;
	} else {
		if (UseQualityControl) {
			if (Loops < DEFAULT_LOOPS_LIMIT) {
				if (ControlQuality()) {
					Loops++;
					goto Loop;
				}
			} else {
				Status = TRNG_NOT_ENOUGH_ENTROPY;
				GeneratorIsRunning = false;
				return;
			}
		} else {
			if (ControlQuality()) {
				Status = TRNG_NOT_ENOUGH_ENTROPY;
				GeneratorIsRunning = false;
				return;
			}
		}
	}
	// last, perform unbiasing
	if (UseUnbiasing) 
		Unbias();
	// increment the counter of succesfully filled buffer
	BuffersGenerated++;
	// before returning mark the generator buffer as ready
    GeneratorBufferIsReady = true;
    GeneratorIsRunning = false;
}

inline void tRNG::CreateGeneratorThread() {
    if (Status) return;
	if ((GeneratorThreadID = _beginthread(ExecuteGenerator, 0, this)) == -1) 
  		Status = TRNG_CANT_START_GENERATOR;
}    

inline void tRNG::InitSource() {
    // do we have a soundcard?
	if (waveInGetNumDevs() == 0) { Status = TRNG_MMSYSTEM_NO_SOUNDCARD; return; }
	// do soundcard support CD-quality recording?
/*  if (MMSYSERR_NOERROR != waveInGetDevCaps(WAVE_MAPPER, &waveincaps, sizeof(WAVEINCAPS))) { Status = TRNG_MMSYSTEM_ERROR; return; }
	if (!waveincaps.dwFormats & WAVE_FORMAT_4S16) { Status = TRNG_MMSYSTEM_NO_SOUNDCARD; return; }
	// initialize soundcard
    waveinputformat.wFormatTag = WAVE_FORMAT_PCM; 
    waveinputformat.nChannels = DEFAULT_CHANNELS; 
    waveinputformat.nSamplesPerSec = DEFAULT_SAMPLERATE; 
    waveinputformat.wBitsPerSample = DEFAULT_SAMPLEDEPTH; 
    waveinputformat.nBlockAlign = waveinputformat.wBitsPerSample * waveinputformat.nChannels / 8;
    waveinputformat.nAvgBytesPerSec = waveinputformat.nBlockAlign * waveinputformat.nSamplesPerSec;
    waveinputformat.cbSize = 0; 
    switch (waveInOpen(&waveinputhandle, WAVE_MAPPER, &waveinputformat, 0, 0, CALLBACK_NULL)) {
		case MMSYSERR_NOERROR:	break;
		case WAVERR_BADFORMAT:	Status = TRNG_MMSYSTEM_WRONG_FORMAT; return;
		default:				Status = TRNG_MMSYSTEM_ERROR; return; 
	} */

	// initialize soundcard
	// new in version 3: automatically select mode gathering more bytes
	int MaxThroughput = 0, MaxThroughputChannel = 0, MaxThroughputRate = 0, MaxThroughputDepth = 0;
	waveinputformat.wFormatTag = WAVE_FORMAT_PCM; 
    waveinputformat.cbSize = 0; 
	_CrtDbgReport(_CRT_WARN, NULL, NULL, NULL, "Detecting supported recording formats\nChan\tRate\tBit\tByte/S\tResult\n");
    for (int r=0; r<SampleRateCount; r++) {
		for (int c=0; c < ChannelCount; c++) {
			for (int d=0; d < SampleDepthCount; d++) {
			    waveinputformat.nChannels = ChannelList[c]; 
				waveinputformat.nSamplesPerSec = SampleRateList[r]; 
				waveinputformat.wBitsPerSample = SampleDepthList[d]; 
				waveinputformat.nBlockAlign = waveinputformat.wBitsPerSample * waveinputformat.nChannels / 8;
				waveinputformat.nAvgBytesPerSec = waveinputformat.nBlockAlign * waveinputformat.nSamplesPerSec;
				MMRESULT Result = waveInOpen(NULL, WAVE_MAPPER, &waveinputformat, 0, 0, WAVE_FORMAT_DIRECT | WAVE_FORMAT_QUERY);
				_CrtDbgReport(_CRT_WARN, NULL, NULL, NULL, "%7d\t%7d\t%7d\t%7d\t%7d\n", waveinputformat.nChannels, waveinputformat.nSamplesPerSec, waveinputformat.wBitsPerSample, waveinputformat.nAvgBytesPerSec, Result);
				if (MMSYSERR_NOERROR == Result) { 
					if (waveinputformat.nAvgBytesPerSec > MaxThroughput) {
						MaxThroughput = waveinputformat.nAvgBytesPerSec;
						MaxThroughputChannel = waveinputformat.nChannels;
						MaxThroughputRate = waveinputformat.nSamplesPerSec;
						MaxThroughputDepth = waveinputformat.wBitsPerSample;
					}
				}
			}
		}
	}
    waveinputformat.nChannels = MaxThroughputChannel; 
	waveinputformat.nSamplesPerSec = MaxThroughputRate; 
	waveinputformat.wBitsPerSample = MaxThroughputDepth; 
	waveinputformat.nBlockAlign = waveinputformat.wBitsPerSample * waveinputformat.nChannels / 8;
	waveinputformat.nAvgBytesPerSec = waveinputformat.nBlockAlign * waveinputformat.nSamplesPerSec;
	_CrtDbgReport(_CRT_WARN, NULL, NULL, NULL, "\nFormat chosen:\n%7d\t%7d\t%7d\t%7d\n\n", waveinputformat.nChannels, waveinputformat.nSamplesPerSec, waveinputformat.wBitsPerSample, waveinputformat.nAvgBytesPerSec);
    switch (waveInOpen(&waveinputhandle, WAVE_MAPPER, &waveinputformat, 0, 0, WAVE_FORMAT_DIRECT | CALLBACK_NULL)) {
		case MMSYSERR_NOERROR:	break;
		case WAVERR_BADFORMAT:	Status = TRNG_MMSYSTEM_WRONG_FORMAT; return;
		default:				Status = TRNG_MMSYSTEM_ERROR; return; 
	}
	if (MMSYSERR_NOERROR != waveInReset(waveinputhandle)) { Status = TRNG_MMSYSTEM_ERROR; return; }
}

inline void tRNG::CloseSource() {
    waveInReset(waveinputhandle);
    waveInClose(waveinputhandle);
}

inline void ExecuteGenerator(void* Class) {
	(reinterpret_cast<tRNG*>(Class)) -> Generate();
}

inline bool tRNG::ControlQuality() {
	int Freq[256], j;
	float Chi = 0;

	memset(Freq, 0, 256*4);
	for (j=0; j<BufferSize; j++) { 
		Freq[GeneratorBuffer[j]]++;
	}
	for (j=0; j<256; j++) { 
		Chi += ((float)BufferSize / (float)256 - (float)Freq[j]) * ((float)BufferSize / (float)256 - (float)Freq[j]);
	}
	Chi /= ((float)BufferSize / (float)256);
	// if the chi is above 50.5% of BufferSize, then probably something is wrong
	_CrtDbgReport(_CRT_WARN, NULL, NULL, NULL, "QualityControl: %.5f\n", 1 - Chi / (BufferSize * 500 / 1000));
	if (Chi > BufferSize * 505 / 1000) { return true; } else { return false; }
}

// Unbias is supposed to unbias the generated data
// It's not working. It will be rewritten to use the unbiasing algorithm I found
// on google (can't remember the name, though).
// Inp1	Inp2 Out
// 0    0    none
// 0    1    0
// 1    0    1
// 1    1    none
inline void tRNG::Unbias() {
	return; // not working
	int* LGeneratorBuffer = reinterpret_cast<int*>(GeneratorBuffer);
	int BitCount = 0, BitDifference;

	// unbiasing is done on a bit basis
	// it assures that the mean of set bits per byte is 4.
	for (int c=0; c<BufferSize>>2; c++)
		BitCount += _popcnt32(LGeneratorBuffer[c]);
	BitDifference = BitCount - (BufferSize << 2);

	for (int BytePos = 0; BitDifference != 0;) {
		// count the number of bits in the int
		if ((BitCount = _popcnt32(LGeneratorBuffer[BytePos])) != 16) {
			BitDifference += 16 - BitCount;
			LGeneratorBuffer[BytePos] = ~LGeneratorBuffer[BytePos];
			BytePos = (BytePos + LGeneratorBuffer[BytePos]) % (BufferSize >> 2);
		}
	}
}

// Dump prints to VC++ debug window the hexadecimal dump of the class
void tRNG::Dump() {
	char dump[sizeof(*this)*2+1];
	char* raw = reinterpret_cast<char*>(this);
	for (int i=0; i<sizeof(*this); i++) sprintf(&dump[i*2], "%02X", raw[i]);
	_CrtDbgReport(_CRT_WARN, NULL, NULL, NULL, "\nHexDump of tRNG object (%d Bytes): %s\n\n", sizeof(*this), dump);
}

// EstimateEntropy returns the estimated number of random bits per sample 
// in the sampled data;
// note: needs to be rewritten to accept 32/24/16/8 bits/sample, not just
// 16 bits
int tRNG::EstimateEntropy(void* buffer) {
	unsigned int Sum = 0;
	short* Buffer = (short*)buffer;
	for (int i=0; i < BufferSize / 2; i++) {
		Sum += abs(Buffer[i]);
	}
	int Mean = Sum / (BufferSize / 2);
	for (i = 0; Mean >> i != 0; i++); // Log2
	return i;
}
	